> 2025年12月28日10:52:10开始

# 暴力法

1. 循环行
2. 统计每行里负数个数 $n$，累加到 $sum$
3. 返回 $sum$

如果遇到面试题肯定不是这么解的，会被当成傻子的

# 优化
注意到题目条件
> 矩阵中的元素无论是按行还是按列，都以非严格递减顺序排列。

以样例矩阵为例：
```python
[
    [ 4,  3,  2, -1],
    [ 3,  2,  1, -1],
    [ 1,  1, -1, -2],
    [-1, -1, -2, -3]
]
```
第 $i$ 行的负数数量$neg_{i}$ 必定满足 $neg_{i+1} \geq neg_{i}$
利用这个规律，我可以减少每行的遍历次数，从而提高效率。

优化后的算法：
1. 定义 $last\_neg\_idx$ 为 $-1$，表示上一行的第一个负数的下标；定义 $last\_neg\_n$ 表示上一行的负数数量 定义 $sum$ 为 $0$，表示累计的负数数量；
2. 循环行，对于每行：
   1. 如果是第一行
      1. 统计该行的负数数量 $n$，累加到 $sum$，记录到 $last\_neg\_n$
      2. 记录改行负数的下标到 $last\_neg\_idx$
   2. 如果不是第一行
      1. 从 $last\_neg\_idx$ 开始，向前搜索，直到遇到第一个非负数或者到顶，记录移动的步数 $step$
      2. 统计该行的负数数量 $n = step + last\_neg\_n$，累加到 $sum$，记录到 $last\_neg\_n$
3. 返回 $sum$

注意到负数的数量 $n_{neg}$ 应当等于矩阵数据量总数减去正数的数量 $n*m - n_{pos}$，而每一行的 $n_{pos} = index_{lastpos} + 1$  所以我们可以改成统计正数的数量，可以少一个中间变量

新的算法
1. 定义 $last\_pos\_idx$ 为 $-1$，表示上一行的第一个正数的下标；定义 $pos\_sum$ 表示所有的正数数量
2. 循环行，对于每行：
   1. 如果是第一行
      1. 统计该行的正数数量 $n$，累加到 $pos\_sum$，记录 $last\_pos\_idx$
   2. 如果不是第一行
      1. 从 $last\_pos\_idx$ 开始，向后搜索，直到遇到第一个负数或者到顶，当前的下标 + 1就是正数数量
3. 返回 $res = n*m - pos\_sum$

> 2025年12月28日11:15:34 passed, 100% 我起了，一套秒了，有什么好说的